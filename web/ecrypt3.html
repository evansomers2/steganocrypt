<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>E-Crypt</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f8f9fa;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    
    h1 {
      text-align: center;
      margin-top: 0;
    }
    
    /* Tab styling */
    .tab-container {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #ccc;
    }
    
    .tab {
      flex: 1;
      text-align: center;
      padding: 10px 0;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s ease;
    }
    
    .tab.active {
      border-bottom: 3px solid #007bff;
      color: #007bff;
    }
    
    .tab:hover {
      background-color: #f0f0f0;
    }
    
    /* Content styling */
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    textarea,
    input[type="password"],
    input[type="file"],
    button {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      font-size: 1rem;
      box-sizing: border-box;
    }
    
    canvas {
      display: block;
      max-width: 100%;
      height: auto;
      margin: 0 auto 10px;
      border: 1px solid #ccc;
    }
    
    /* Center the preview image on the decode page */
    img#previewImage {
      display: none;
      max-width: 100%;
      margin: 10px auto; /* centers the image */
    }
    
    a {
      display: inline-block;
      width: 100%;
      text-align: center;
      text-decoration: none;
      background-color: #007bff;
      color: #fff;
      padding: 10px 0;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    
    a:hover {
      background-color: #0056b3;
    }
    
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>E-Crypt</h1>
    
    <!-- Tab Navigation -->
    <div class="tab-container">
      <div class="tab active" id="encodeTabBtn">Encode</div>
      <div class="tab" id="decodeTabBtn">Decode</div>
    </div>
    
    <!-- Encode Tab Content -->
    <div class="tab-content active" id="encodeTab">
      <h2>Encoding</h2>
      <textarea id="message" placeholder="Enter message to encode"></textarea>
      <input type="password" id="password" placeholder="Enter password">
      <button id="encodeBtn">Encode</button>
      <canvas id="canvas" width="100" height="100"></canvas>
      <a id="downloadLink" download="encoded.png">Download Encoded Image</a>
    </div>
    
    <!-- Decode Tab Content -->
    <div class="tab-content" id="decodeTab">
      <h2>Decoding</h2>
      <input type="file" id="uploadImage">
      <!-- Preview image appears once a file is loaded -->
      <img id="previewImage" alt="Loaded Image Preview">
      <input type="password" id="decPassword" placeholder="Enter password">
      <button id="decodeBtn">Decode</button>
      <p id="decodedMessage"></p>
    </div>
  </div>
  
  <script>
    /*********************
     * Tab Switching Logic
     *********************/
    const encodeTabBtn = document.getElementById('encodeTabBtn');
    const decodeTabBtn = document.getElementById('decodeTabBtn');
    const encodeTab = document.getElementById('encodeTab');
    const decodeTab = document.getElementById('decodeTab');

    encodeTabBtn.addEventListener('click', () => {
      encodeTabBtn.classList.add('active');
      decodeTabBtn.classList.remove('active');
      encodeTab.classList.add('active');
      decodeTab.classList.remove('active');
    });

    decodeTabBtn.addEventListener('click', () => {
      decodeTabBtn.classList.add('active');
      encodeTabBtn.classList.remove('active');
      decodeTab.classList.add('active');
      encodeTab.classList.remove('active');
    });

    /*********************
     * Helper Functions
     *********************/
    
    // A simple hash function (cyrb128) to generate a seed from a string (password)
    function cyrb128(str) {
      let h1 = 1779033703, h2 = 3144134277,
          h3 = 1013904242, h4 = 2773480762;
      for (let i = 0, k; i < str.length; i++) {
          k = str.charCodeAt(i);
          h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
          h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
          h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
          h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
      }
      return [h1 >>> 0, h2 >>> 0, h3 >>> 0, h4 >>> 0];
    }

    // Mulberry32 PRNG â€” returns a function that generates pseudo-random numbers in [0,1)
    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }

    // Converts a string into a binary string (8 bits per character)
    function stringToBinary(str) {
      return str.split('').map(function(char) {
        return char.charCodeAt(0).toString(2).padStart(8, '0');
      }).join('');
    }

    // Converts a binary string back into text (8 bits per character)
    function binaryToString(binStr) {
      let text = '';
      for (let i = 0; i < binStr.length; i += 8) {
        let byte = binStr.substr(i, 8);
        text += String.fromCharCode(parseInt(byte, 2));
      }
      return text;
    }

    // Generates a pseudo-random order (array of pixel indices) using a seeded shuffle
    function generatePixelOrder(totalPixels, seed) {
      let indices = Array.from({length: totalPixels}, (_, i) => i);
      let rand = mulberry32(seed);
      // Fisher-Yates shuffle
      for (let i = indices.length - 1; i > 0; i--) {
        let j = Math.floor(rand() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      return indices;
    }

    /*********************
     * Encoding Function
     *********************/
    document.getElementById('encodeBtn').addEventListener('click', function() {
      let message = document.getElementById('message').value;
      let password = document.getElementById('password').value;
      if (!message || !password) {
        alert("Please enter both a message and a password.");
        return;
      }

      // Create header: 16 bits representing message length (in characters)
      if (message.length > 65535) {
        alert("Message too long. Maximum length is 65535 characters.");
        return;
      }
      let header = message.length.toString(2).padStart(16, '0');
      let messageBin = stringToBinary(message);
      let fullBinary = header + messageBin;
      let totalBits = fullBinary.length;

      // Set up canvas and get its context
      let canvas = document.getElementById('canvas');
      let ctx = canvas.getContext('2d');
      let width = canvas.width;
      let height = canvas.height;
      let totalPixels = width * height;

      if (totalBits > totalPixels) {
        alert("Message too long for the canvas size. Use a smaller message or a larger canvas.");
        return;
      }

      // Create a new ImageData object for the canvas
      let imageData = ctx.createImageData(width, height);
      let data = imageData.data;

      // Use the password to seed the PRNG for generating random colors and pixel order
      let seedArray = cyrb128(password);
      let seed = seedArray[0]; // using the first value from the hash
      let rand = mulberry32(seed);

      // For each pixel, assign random RGB values and set alpha to 255 (fully opaque)
      for (let i = 0; i < totalPixels; i++) {
        data[i*4] = Math.floor(rand() * 256);       // Red
        data[i*4 + 1] = Math.floor(rand() * 256);     // Green
        data[i*4 + 2] = Math.floor(rand() * 256);     // Blue
        data[i*4 + 3] = 255;                          // Alpha (opaque by default)
      }

      // Generate a pseudo-random order of pixel indices using the same seed
      let pixelOrder = generatePixelOrder(totalPixels, seed);

      // Encode the binary data into the alpha channel (using LSB encoding) of the first totalBits pixels
      for (let i = 0; i < totalBits; i++) {
        let pixelIndex = pixelOrder[i];
        let bit = fullBinary[i];
        // Use LSB encoding on alpha: if bit is '1', leave alpha as 255 (odd); if '0', change to 254 (even)
        data[pixelIndex*4 + 3] = (bit === '0') ? 254 : 255;
      }

      // Draw the modified image data to the canvas
      ctx.putImageData(imageData, 0, 0);

      // Update the download link so you can save the image
      let downloadLink = document.getElementById('downloadLink');
      downloadLink.href = canvas.toDataURL();
    });

    /*********************
     * Decode File Preview
     *********************/
    // When a file is selected, show its preview in the decode tab.
    document.getElementById('uploadImage').addEventListener('change', function() {
      let fileInput = this;
      if (fileInput.files && fileInput.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          let previewImage = document.getElementById('previewImage');
          previewImage.src = e.target.result;
          previewImage.style.display = "block";
        }
        reader.readAsDataURL(fileInput.files[0]);
      }
    });

    /*********************
     * Decoding Function
     *********************/
    document.getElementById('decodeBtn').addEventListener('click', function() {
      let fileInput = document.getElementById('uploadImage');
      let password = document.getElementById('decPassword').value;
      if (fileInput.files.length === 0 || !password) {
        alert("Please upload an image and enter the password.");
        return;
      }
      let file = fileInput.files[0];
      let img = new Image();
      let reader = new FileReader();
      reader.onload = function(e) {
        img.src = e.target.result;
      }
      img.onload = function() {
        // Create a temporary canvas to load the image
        let canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        let ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let data = imageData.data;
        let totalPixels = canvas.width * canvas.height;

        // Recreate the pseudo-random pixel order using the same password
        let seedArray = cyrb128(password);
        let seed = seedArray[0];
        let pixelOrder = generatePixelOrder(totalPixels, seed);

        // Read the first 16 bits from the alpha channel to get the header (message length)
        let headerBits = "";
        for (let i = 0; i < 16; i++) {
          let pixelIndex = pixelOrder[i];
          let alpha = data[pixelIndex*4 + 3];
          // If alpha is even, then bit is '0'; if odd, then bit is '1'
          headerBits += (alpha % 2 === 0 ? '0' : '1');
        }
        let messageLength = parseInt(headerBits, 2);
        let totalMessageBits = messageLength * 8;
        let messageBits = "";
        // Read the next totalMessageBits pixels for the message data
        for (let i = 16; i < 16 + totalMessageBits; i++) {
          let pixelIndex = pixelOrder[i];
          let alpha = data[pixelIndex*4 + 3];
          messageBits += (alpha % 2 === 0 ? '0' : '1');
        }
        let message = binaryToString(messageBits);
        document.getElementById('decodedMessage').textContent = "Decoded Message: " + message;
      }
      reader.readAsDataURL(file);
    });
  </script>
</body>
</html>
