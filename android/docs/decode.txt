Technical Documentation for Steganography Decoding Process
1. Overview

This code implements a corresponding decoding process for a steganographic system that hides messages in PNG images. The hidden data is embedded in the least significant bit (LSB) of the alpha channel of each pixel. The process uses a user-provided password to:

    Generate deterministic seeds for pseudo-random number generation.
    Reconstruct a randomized pixel order that matches the encoding process.
    Decode a 16-bit header (indicating the message length) and subsequently extract the hidden message bits.

The decoded message is then converted from binary to text and displayed to the user.
2. Dependencies and Environment

The implementation uses the following libraries and modules:

    React & React Native: For building the UI and managing component state.
    Expo Modules:
        expo-image-picker for selecting images from the device’s library.
    UPNG-js: For decoding PNG images and extracting raw pixel data.

Ensure these libraries are installed and configured in your React Native/Expo project.
3. Helper Functions
3.1. cyrb128

    Purpose:
    Generates a 128-bit hash from a string (the password) and returns an array of four 32-bit unsigned integers.
    Usage:
    Used to derive seeds that control the pseudo-random processes (pixel shuffling) ensuring that the decoding order matches the encoding order.
    Key Operations:
    Iterates over the characters of the password and performs bitwise and multiplication operations.

const cyrb128 = (str) => {
  let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
  for (let i = 0, k; i < str.length; i++) {
      k = str.charCodeAt(i);
      h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
      h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
      h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
      h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
  }
  return [h1 >>> 0, h2 >>> 0, h3 >>> 0, h4 >>> 0];
};

3.2. mulberry32

    Purpose:
    Provides a fast, seeded pseudo-random number generator (PRNG) that returns values between 0 and 1.
    Usage:
    Used by the pixel order generation function to shuffle indices in a deterministic manner based on the password.
    Key Operations:
    Uses bitwise shifts and multiplications to generate pseudo-random numbers.

const mulberry32 = (a) => {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
};

3.3. generatePixelOrder

    Purpose:
    Produces a randomized permutation of pixel indices for an image.
    Usage:
    Determines the order in which pixels are read to extract the header and message bits.
    Key Operations:
    Implements the Fisher-Yates shuffle algorithm using the seeded PRNG to ensure consistent shuffling when the same password is used.

const generatePixelOrder = (totalPixels, seed) => {
  let indices = Array.from({ length: totalPixels }, (_, i) => i);
  let rand = mulberry32(seed);
  for (let i = indices.length - 1; i > 0; i--) {
    let j = Math.floor(rand() * (i + 1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  return indices;
};

3.4. binaryToString

    Purpose:
    Converts a binary string (sequence of 0s and 1s) back into a readable text message.
    Usage:
    After extracting the hidden binary data from the image, this function groups bits into bytes (8 bits) and converts them to characters.
    Key Operations:
    Iterates over the binary string in 8-bit chunks and converts each chunk to its corresponding ASCII character.

const binaryToString = (binStr) => {
  let text = '';
  for (let i = 0; i < binStr.length; i += 8) {
    let byte = binStr.substr(i, 8);
    text += String.fromCharCode(parseInt(byte, 2));
  }
  return text;
};

4. The Decoding Process in DecodeScreen
4.1. UI and State Management

    State Variables:
        imageUri: Stores the URI of the selected image.
        password: Holds the user-provided password.
        decodedMessage: Used to display the decoded message.
        imageData: Holds the raw pixel data extracted from the image.
    User Interaction:
    Users select an image from their library and input the password to trigger the decoding process.

4.2. Image Selection and Pixel Data Extraction

    Image Picker:
    The pickImage function uses Expo’s ImagePicker to let the user select an image. Upon selection, it calls getImagePixelData to fetch and decode the image.

    Fetching and Decoding Image Data:
        Fetch:
        The image is fetched as an ArrayBuffer via a network request.
        Decode PNG:
        UPNG’s decode function is used to decode the PNG file, and UPNG.toRGBA8 converts the decoded data into RGBA frames.
        Data Verification:
        The code performs checks on the returned pixel data and logs key information (dimensions, data length).

async function getImagePixelData(uri) {
  try {
    const response = await fetch(uri);
    if (!response.ok) {
      throw new Error(`Network response was not ok, status: ${response.status}`);
    }
    const arrayBuffer = await response.arrayBuffer();
    console.log("ArrayBuffer byteLength:", arrayBuffer.byteLength);
  
    if (arrayBuffer.byteLength === 0) {
      throw new Error("Fetched ArrayBuffer is empty.");
    }
  
    const pngData = UPNG.decode(arrayBuffer);
    const frames = UPNG.toRGBA8(pngData);
    if (!frames || frames.length === 0) {
      throw new Error("No frames decoded from PNG image.");
    }
    const pixelData = frames[0];
    console.log("Pixel data length:", pngData.data.length);
  
    const { width, height } = pngData;
    console.log("Width:", width, "Height:", height);
  
    if (pixelData.length !== width * height * 4) {
      console.warn("Unexpected pixel data length:", pixelData.length);
    }
    return { width, height, data: pngData.data };
  } catch (error) {
    console.error("Error fetching or decoding PNG image:", error);
    return null;
  }
}

4.3. Decoding the Hidden Message

    Image Assumptions:
    The code assumes that the image dimensions are 100×100 pixels (i.e., 10,000 pixels total).

    Seed and Pixel Order Generation:
        The user-provided password is hashed using cyrb128 to produce a seed.
        The pixel order is regenerated with generatePixelOrder using this seed, ensuring the same ordering as in the encoding process.

    Header Decoding:
        Header Bits:
        The first 16 pixels (based on the shuffled order) are processed to extract the LSB of their alpha channel.
        Message Length:
        The 16-bit binary header is converted to an integer which indicates the number of characters (bytes) in the hidden message.

let headerBits = "";
for (let i = 0; i < 16; i++) {
  const pixelIndex = pixelOrder[i];
  const alpha = imageData[pixelIndex * 4 + 3];
  headerBits += alpha % 2 === 0 ? "0" : "1";
}
const messageLength = parseInt(headerBits, 2);
console.log("Message length (in bytes):", messageLength);

    Message Decoding:
        Message Bits:
        Based on the header, the next messageLength * 8 pixels (again using the randomized order) are read, and their alpha channel LSBs are concatenated to form the message’s binary string.
        Conversion to Text:
        The binaryToString function converts the binary string into a human-readable text message.

const totalMessageBits = messageLength * 8;
let messageBits = "";
for (let i = 16; i < 16 + totalMessageBits; i++) {
  const pixelIndex = pixelOrder[i];
  const alpha = imageData[pixelIndex * 4 + 3];
  messageBits += alpha % 2 === 0 ? "0" : "1";
}
const message = binaryToString(messageBits);
console.log("Decoded Message:", message);
Alert.alert("Decoded Message:", message);

4.4. Error Handling and User Feedback

    Validation:
    The code checks that both image data and a password are provided before attempting to decode.
    Alerts and Logging:
    Alerts are used to inform the user of errors or success, and console logs help with debugging during development.

5. UI and Component Structure
5.1. Component Layout

    Image Picker Button:
    Allows users to select an image from their device.
    Password Input Field:
    Accepts the password that was used during encoding.
    Decode Button:
    Triggers the decoding process.
    Image Preview:
    Displays the selected image.
    Decoded Message Display:
    Shows the decoded hidden message.

5.2. Styling

    The component uses StyleSheet for consistent styling of inputs, buttons, and images, making it mobile-friendly and easy to customize.

<ScrollView contentContainerStyle={styles.container}>
  <Text style={styles.title}>Decode Hidden Message</Text>
  <Button title="Pick Image" onPress={pickImage} />
  {imageUri && <Image source={{ uri: imageUri }} style={styles.image} />}
  <TextInput
    style={styles.input}
    placeholder="Enter Password"
    value={password}
    onChangeText={setPassword}
    secureTextEntry
  />
  <Button title="Decode" onPress={decodeMessage} />
  <Text style={styles.message}>{decodedMessage}</Text>
</ScrollView>

6. Considerations and Limitations

    Image Compatibility:
    The decoding assumes that the image is 100×100 pixels and was encoded using the corresponding encoding process. Altering or compressing the image may corrupt the hidden data.

    Password Dependency:
    The correct password is critical since it regenerates the pixel order. A different password will produce a different pixel order, causing the decoding to fail.

    Steganography Limitations:
    LSB steganography is relatively simple and can be vulnerable to statistical analysis. For more robust solutions, consider additional encryption or error correction.

    Error Handling:
    The code includes basic error handling, but in production scenarios, more robust error management and user feedback mechanisms should be implemented.

7. Conclusion

This decoding process provides a developer-friendly example of extracting a hidden message from a PNG image by reading the LSB of the alpha channel. The use of a password to generate a deterministic pixel order ensures that the encoding and decoding processes are synchronized. Developers can extend this framework by adding features like encryption, dynamic image sizing, or improved error handling to create a more robust steganographic application.

Feel free to refer to the code comments and this documentation for further clarification or for making improvements to the implementation.