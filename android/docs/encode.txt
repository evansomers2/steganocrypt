Technical Documentation for Steganography Encoding Process
1. Overview

This code implements a simple form of steganography where a secret message is encoded into a 100×100 PNG image by modifying the least significant bit (LSB) of each pixel’s alpha channel. The process uses a user-provided password to:

    Generate seeds for pseudo-random number generation.
    Randomize the pixel order for encoding both a header (storing message length) and the message itself.

The resulting image appears as a visually random noise image (with random RGB values) while hiding the message data within the alpha channel.
2. Dependencies and Environment

The implementation uses the following libraries and modules:

    React & React Native: For building the UI and handling state.
    Expo Modules:
        expo-file-system for file I/O.
        expo-media-library for saving images to the device gallery.
    UPNG-js: For encoding raw pixel data into a PNG image.

Ensure that these libraries are installed and properly configured within your React Native/Expo project.
3. Helper Functions
3.1. cyrb128

    Purpose:
    Generates a 128-bit hash from a string (password) and returns an array of four 32-bit unsigned integers.
    Usage in Code:
    Used to derive multiple seeds from the user password. One seed is used for the pixel order randomization and another for generating random RGB values.
    Algorithm Highlights:
    Iterates over each character in the string and performs bitwise and arithmetic operations (using Math.imul) to mix the bits.

const cyrb128 = (str) => {
  let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
  for (let i = 0, k; i < str.length; i++) {
    k = str.charCodeAt(i);
    h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
    h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
    h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
    h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
  }
  return [h1 >>> 0, h2 >>> 0, h3 >>> 0, h4 >>> 0];
};

3.2. mulberry32

    Purpose:
    Implements a fast pseudo-random number generator (PRNG) that uses a 32-bit seed.
    Usage in Code:
    Generates random values both for creating the random RGB colors for pixels and for shuffling the pixel order.
    Algorithm Highlights:
    The PRNG uses bitwise shifts and multiplications to produce a sequence of pseudo-random numbers in the range [0, 1).

const mulberry32 = (a) => {
  return function () {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
};

3.3. generatePixelOrder

    Purpose:
    Produces a randomized permutation of pixel indices for a given image.
    Usage in Code:
    Determines the order in which pixels will be used to encode the header (message length) and the message bits.
    Algorithm Highlights:
    Uses the Fisher-Yates shuffle algorithm with the seeded PRNG to ensure reproducibility based on the password.

const generatePixelOrder = (totalPixels, seed) => {
  let indices = Array.from({ length: totalPixels }, (_, i) => i);
  let rand = mulberry32(seed);
  for (let i = indices.length - 1; i > 0; i--) {
    let j = Math.floor(rand() * (i + 1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  return indices;
};

3.4. stringToBinary

    Purpose:
    Converts a text string into its binary representation (8 bits per character).
    Usage in Code:
    Transforms the secret message into a stream of binary digits for embedding.
    Algorithm Highlights:
    Iterates through the string and pads each character’s binary conversion to ensure 8 bits.

const stringToBinary = (str) => {
  let binary = '';
  for (let i = 0; i < str.length; i++) {
    let bin = str.charCodeAt(i).toString(2);
    binary += bin.padStart(8, '0');
  }
  return binary;
};

3.5. arrayBufferToBase64

    Purpose:
    Converts an ArrayBuffer (e.g., PNG image data) into a Base64-encoded string.
    Usage in Code:
    Enables the creation of a data URI that can be used to display the generated image in the app.
    Algorithm Highlights:
    Iterates through the bytes in the buffer and converts each to a character before encoding the full string using btoa.

const arrayBufferToBase64 = async (buffer) => {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
};

4. The Encoding Process in EncodeScreen
4.1. Input Validation and Setup

    User Inputs:
    The process requires a secret message and a password.
    Image Dimensions:
    The image is hard-coded as a 100×100 pixel canvas, totaling 10,000 pixels.
    State Management:
    React’s useState is used to manage the message, password, generated image URI, and loading state.

4.2. Pixel Data Generation

    Random RGB Generation:
    Each pixel is assigned random red, green, and blue values generated using mulberry32 seeded with one of the values from cyrb128(password).
    Alpha Channel Initialization:
    The alpha (transparency) channel for each pixel is initially set to 254 (an even number) to ensure a consistent starting point.

const pixelData = new Uint8Array(totalPixels * 4);
const seedArray = cyrb128(password);
const rand = mulberry32(seedArray[1]);

for (let i = 0; i < totalPixels; i++) {
  pixelData[i * 4] = Math.floor(rand() * 256);     // R
  pixelData[i * 4 + 1] = Math.floor(rand() * 256); // G
  pixelData[i * 4 + 2] = Math.floor(rand() * 256); // B
  pixelData[i * 4 + 3] = 254;                     // A (default even)
}

4.3. Message Preparation

    Header:
    A 16-bit header is created that encodes the length of the secret message in characters. This allows the decoding process to know how many bits to extract.

const messageLength = message.length;
const headerBinary = messageLength.toString(2).padStart(16, '0');

Message Conversion:
The message is converted into a binary string where each character is represented by 8 bits.

    const messageBinary = stringToBinary(message);

    Size Validation:
    Ensures that the message (plus header) does not exceed the number of available pixels.

4.4. Pixel Order Randomization

    Purpose:
    To obscure where data bits are hidden, the pixel indices are shuffled using a PRNG seeded with another value from cyrb128(password).

    const pixelOrder = generatePixelOrder(totalPixels, seedArray[0]);

4.5. Encoding the Data

    Header Encoding:
    The first 16 pixels (based on the randomized order) have their alpha channel LSB modified to encode each bit of the header.

for (let i = 0; i < 16; i++) {
  const pixelIndex = pixelOrder[i];
  const alphaIndex = pixelIndex * 4 + 3;
  const bit = parseInt(headerBinary[i], 10);
  pixelData[alphaIndex] = (pixelData[alphaIndex] & 0xFE) | bit;
}

Message Encoding:
Following the header, each subsequent pixel (again, in the randomized order) is used to encode one bit of the secret message.

    for (let i = 0; i < messageBinary.length; i++) {
      const pixelIndex = pixelOrder[16 + i];
      const alphaIndex = pixelIndex * 4 + 3;
      const bit = parseInt(messageBinary[i], 10);
      pixelData[alphaIndex] = (pixelData[alphaIndex] & 0xFE) | bit;
    }

    Note: The operation (value & 0xFE) | bit clears the least significant bit of the alpha channel and then sets it to the desired bit value.

4.6. Image Encoding and Display

    PNG Creation:
    The modified pixel data is encoded into a PNG image using UPNG.encode.

    Base64 Conversion:
    The PNG binary data is then converted into a Base64 string so it can be displayed as a data URI in the app.

    const pngBuffer = UPNG.encode([pixelData.buffer], width, height, 0);
    const base64Encoded = await arrayBufferToBase64(pngBuffer);
    const imageUri = `data:image/png;base64,${base64Encoded}`;
    setEncodedImageUri(imageUri);

    User Feedback:
    Alerts are used to notify the user upon success or error.

5. Saving the Image

The saveImage function handles writing the encoded image to the device’s file system and then saving it to the device’s media library (gallery).

    FileSystem:
    Writes the Base64-encoded image data to a temporary file.
    MediaLibrary:
    Requests permissions and creates an asset in the gallery under an album named "Encoded Images".

const saveImage = async () => {
  if (!encodedImageUri) {
    Alert.alert('Error', 'No encoded image to save.');
    return;
  }
  try {
    const fileUri = `${FileSystem.cacheDirectory}encoded-image.png`;
    const base64Data = encodedImageUri.split(',')[1];
    await FileSystem.writeAsStringAsync(fileUri, base64Data, {
      encoding: FileSystem.EncodingType.Base64,
    });
    const { status } = await MediaLibrary.requestPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert('Permission Denied', 'Cannot save image without permission.');
      return;
    }
    const asset = await MediaLibrary.createAssetAsync(fileUri);
    await MediaLibrary.createAlbumAsync('Encoded Images', asset, false);
    Alert.alert('Success', 'Encoded image saved to gallery!');
  } catch (error) {
    console.error('Save Error:', error);
    Alert.alert('Error', 'An error occurred while saving the image.');
  }
};

6. Considerations and Limitations

    Message Length:
    The header supports a maximum message length of 65,535 characters. Moreover, the total bits required for the header and message must not exceed the number of pixels available (10,000 pixels for a 100×100 image).

    Steganography Limitations:
        Detection:
        LSB steganography is relatively simple and can be detected by statistical analysis.
        Robustness:
        Altering or compressing the image after encoding might destroy the hidden message.
        Image Dimensions:
        Hard-coded image dimensions mean that larger messages require either a larger image or a different encoding strategy.

    Security:
    The password influences both the random RGB generation and the pixel order. Although this adds obfuscation, the scheme is not cryptographically secure against dedicated steganalysis.

7. Potential Enhancements

    Encryption:
    Encrypt the message before encoding to add an extra layer of security.
    Error Correction:
    Include redundancy or error-correcting codes to improve robustness against image processing artifacts.
    Dynamic Image Size:
    Allow dynamic image dimensions based on message length.
    Multiple Channels:
    Consider encoding data in additional color channels if visual quality is not a concern.

8. Conclusion

This steganography encoding process provides a developer-friendly example of hiding a text message within a PNG image by modifying the LSB of the alpha channel. The use of a password to seed random number generators ensures that the encoding pattern is non-obvious, albeit not foolproof. Developers can build upon this foundation to create more robust, secure, or feature-rich steganographic applications.

Feel free to refer to the code comments and this documentation for further clarification or for making improvements to the implementation.